name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history and tags for release notes generation

      - name: Get version
        id: get_version
        run: echo "version=${GITHUB_REF#refs/tags/}" >> "$GITHUB_OUTPUT"

      - name: Generate release notes from commits
        id: generate_notes
        run: |
          # Get the current tag
          CURRENT_TAG="${GITHUB_REF#refs/tags/}"
          
          # Get the previous tag
          PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -v "^$CURRENT_TAG$" | head -1)
          
          # Generate release notes from commits
          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Generating release notes between $PREVIOUS_TAG and $CURRENT_TAG"
            
            # Get commits between tags, excluding version bump commits
            COMMITS=$(git log "$PREVIOUS_TAG..$CURRENT_TAG" --oneline --pretty=format:"- %s" | grep -v "^- chore: bump version" | grep -v "^- Bump version")
            
            if [ -n "$COMMITS" ]; then
              cat << EOF > release_notes.md
          # Rusty Commit $CURRENT_TAG üöÄ
          
          **Rust-powered AI commit message generator - Write impressive commits in seconds** ü¶Äü§ñ
          
          ## What's Changed
          
          $COMMITS
          
          ## About Rusty Commit
          
          Rusty Commit is a blazing-fast commit message generator that supports 16+ AI providers including:
          - üß† **Anthropic Claude** (Claude 3.5 Sonnet, Haiku)
          - ü§ñ **OpenAI** (GPT-4, GPT-3.5 Turbo) 
          - üî• **Groq** (Llama 3, Mixtral)
          - ‚ö° **DeepSeek** (DeepSeek Coder)
          - üåü **OpenRouter** (Access to 100+ models)
          - And many more!
          
          ## Key Features
          - üîê **Secure Storage**: System keychain integration for API keys
          - üéØ **Smart Analysis**: Analyzes staged changes for context-aware commits
          - üöÄ **Cross-Platform**: Works on macOS, Linux, and Windows
          - üîÑ **OpenCommit Compatible**: Drop-in replacement with enhanced performance
          - üé® **Interactive UI**: Beautiful provider selection and authentication flow
          
          ## Installation
          
          ### Quick Install (Recommended)
          \`\`\`bash
          # macOS/Linux
          curl -fsSL https://github.com/${{ github.repository }}/releases/download/$CURRENT_TAG/install.sh | bash
          
          # Or download directly
          curl -L https://github.com/${{ github.repository }}/releases/download/$CURRENT_TAG/rustycommit-\$(uname -s)-\$(uname -m).tar.gz | tar xz
          sudo mv rco /usr/local/bin/
          \`\`\`
          
          ### Using Cargo
          \`\`\`bash
          cargo install rusty-commit
          # With secure storage
          cargo install rusty-commit --features secure-storage
          \`\`\`
          
          ### Package Managers
          - **Homebrew**: \`brew install hongkongkiwi/tap/rusty-commit\`
          - **Alpine Linux**: Available in our custom repository
          - **Arch Linux**: \`yay -S rusty-commit\` (AUR)
          
          ## Getting Started
          
          \`\`\`bash
          # Interactive setup with provider selection
          rco auth
          
          # Generate a commit message
          git add .
          rco
          
          # Or use specific provider
          rco --provider anthropic
          \`\`\`
          
          ---
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...$CURRENT_TAG
          EOF
            else
              cat << EOF > release_notes.md
          # Rusty Commit $CURRENT_TAG üöÄ
          
          **Rust-powered AI commit message generator - Write impressive commits in seconds** ü¶Äü§ñ
          
          ## What's Changed
          
          - Maintenance release with internal improvements
          
          ## Installation & Usage
          
          See our [README](https://github.com/${{ github.repository }}#installation) for installation instructions.
          
          ---
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...$CURRENT_TAG
          EOF
            fi
          else
            cat << EOF > release_notes.md
          # Rusty Commit $CURRENT_TAG üöÄ
          
          **Rust-powered AI commit message generator - Write impressive commits in seconds** ü¶Äü§ñ
          
          Initial release with full feature set.
          EOF
          fi
          
          # Set output for use in release creation
          {
            echo "notes<<EOF"
            cat release_notes.md
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref }}
          name: Release ${{ steps.get_version.outputs.version }}
          draft: false
          prerelease: false
          generate_release_notes: false
          body: ${{ steps.generate_notes.outputs.notes }}

  build-release:
    name: Build Release (${{ matrix.target }})
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          # Linux builds
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            archive-name: rustycommit-linux-x86_64.tar.gz
            use-cross: false

          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            archive-name: rustycommit-linux-x86_64-musl.tar.gz
            use-cross: true

          - os: ubuntu-latest
            target: aarch64-unknown-linux-musl
            archive-name: rustycommit-linux-aarch64-musl.tar.gz
            use-cross: true

          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            archive-name: rustycommit-linux-aarch64.tar.gz
            use-cross: true

          - os: ubuntu-latest
            target: riscv64gc-unknown-linux-gnu
            archive-name: rustycommit-linux-riscv64.tar.gz
            use-cross: true

          - os: ubuntu-latest
            target: riscv64gc-unknown-linux-musl
            archive-name: rustycommit-linux-musl-riscv64.tar.gz
            use-cross: true

          - os: ubuntu-latest
            target: armv7-unknown-linux-gnueabihf
            archive-name: rustycommit-linux-armv7.tar.gz
            use-cross: true

          # macOS builds  
          - os: macos-latest
            target: x86_64-apple-darwin
            archive-name: rustycommit-macos-x86_64.tar.gz
            use-cross: false

          - os: macos-latest
            target: aarch64-apple-darwin
            archive-name: rustycommit-macos-aarch64.tar.gz
            use-cross: false

          # Windows builds
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            archive-name: rustycommit-windows-x86_64.zip
            use-cross: false

          - os: windows-latest
            target: i686-pc-windows-msvc
            archive-name: rustycommit-windows-i686.zip
            use-cross: false
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@nightly
        with:
          targets: ${{ matrix.target }}

      - name: Install cross
        if: matrix.use-cross
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Add target toolchain
        if: matrix.use-cross == false
        run: rustup target add ${{ matrix.target }}

      - name: Build with cross
        if: matrix.use-cross
        run: cross build --release --target ${{ matrix.target }}

      - name: Build with cargo
        if: ${{ !matrix.use-cross }}
        run: cargo build --release --target ${{ matrix.target }}

      - name: Create archive (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          mkdir -p archive
          cp "target/${{ matrix.target }}/release/rco" archive/ 2>/dev/null || true
          # Include documentation and scripts
          cp README.md archive/ 2>/dev/null || true
          cp README_OAUTH.md archive/ 2>/dev/null || true
          cp INSTALL.md archive/ 2>/dev/null || true
          cp LICENSE archive/ 2>/dev/null || true
          cp install.sh archive/ 2>/dev/null || true
          # Include shell completions
          mkdir -p archive/completions
          cp -r completions/* archive/completions/ 2>/dev/null || true
          # Include man page
          mkdir -p archive/man
          cp -r man/* archive/man/ 2>/dev/null || true
          # Create a simple version file
          echo "${{ needs.create-release.outputs.version }}" > archive/VERSION
          cd archive
          tar czf "../${{ matrix.archive-name }}" .

      - name: Create archive (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path archive
          Copy-Item "target\${{ matrix.target }}\release\rco.exe" -Destination "archive\"
          # Include documentation
          Copy-Item "README.md" -Destination "archive\" -ErrorAction SilentlyContinue
          Copy-Item "README_OAUTH.md" -Destination "archive\" -ErrorAction SilentlyContinue
          Copy-Item "INSTALL.md" -Destination "archive\" -ErrorAction SilentlyContinue
          Copy-Item "LICENSE" -Destination "archive\" -ErrorAction SilentlyContinue
          Copy-Item "install.sh" -Destination "archive\" -ErrorAction SilentlyContinue
          # Include shell completions
          New-Item -ItemType Directory -Force -Path "archive\completions"
          Copy-Item "completions\*" -Destination "archive\completions\" -Recurse -ErrorAction SilentlyContinue
          # Include man page
          New-Item -ItemType Directory -Force -Path "archive\man"
          Copy-Item "man\*" -Destination "archive\man\" -Recurse -ErrorAction SilentlyContinue
          # Create version file
          "${{ needs.create-release.outputs.version }}" | Out-File -FilePath "archive\VERSION" -Encoding UTF8
          Compress-Archive -Path "archive\*" -DestinationPath "${{ matrix.archive-name }}"

      - name: Upload Release Asset
        uses: softprops/action-gh-release@v2
        with:
          files: ./${{ matrix.archive-name }}
          tag_name: ${{ github.ref }}

  # Crate publishing is now handled by publish.yml which triggers on release published event
  # OS package creation is handled by package-release.yml which also triggers on release published event

  # Sign and finalize release artifacts
  sign-and-finalize:
    name: Sign Release Artifacts
    needs: [create-release, build-release]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write  # Required for Sigstore keyless signing
      attestations: write  # Required for GitHub attestations
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.7.0
        with:
          cosign-release: 'v2.2.2'

      - name: Configure Cosign key
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        run: |
          if [ -z "${COSIGN_PRIVATE_KEY:-}" ]; then
            echo "ERROR: COSIGN_PRIVATE_KEY secret is not configured"
            echo "Please set up the COSIGN_PRIVATE_KEY secret in repository settings"
            exit 1
          fi
          
          echo "$COSIGN_PRIVATE_KEY" | base64 -d > cosign.key
          chmod 600 cosign.key
          
          if [ -n "${COSIGN_PASSWORD:-}" ]; then
            echo "COSIGN_PASSWORD=$COSIGN_PASSWORD" >> "$GITHUB_ENV"
          fi
          echo "COSIGN_KEY_ARGS=--key cosign.key" >> "$GITHUB_ENV"

      - name: Setup GPG
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          if [ -n "${GPG_PRIVATE_KEY:-}" ] && [ -n "${GPG_PASSPHRASE:-}" ]; then
            # Import GPG key
            echo "$GPG_PRIVATE_KEY" | base64 -d | gpg --batch --import

            # Configure GPG
            mkdir -p ~/.gnupg
            chmod 700 ~/.gnupg
            {
              echo "allow-loopback-pinentry"
            } >> ~/.gnupg/gpg-agent.conf
            {
              echo "use-agent"
            } >> ~/.gnupg/gpg.conf
            gpg-connect-agent reloadagent /bye

            # Test signing
            echo "test" | gpg --batch --yes --passphrase "$GPG_PASSPHRASE" \
                --pinentry-mode loopback --armor --detach-sign > /dev/null

            echo "GPG signing configured successfully"
            echo "GPG_CONFIGURED=true" >> "$GITHUB_ENV"
          else
            echo "GPG key not configured, skipping GPG signing"
            echo "GPG_CONFIGURED=false" >> "$GITHUB_ENV"
          fi

      - name: Sign all artifacts with Cosign (keyless or key-based)
        run: |
          cd artifacts
          # Sign all package types with Cosign keyless signing
          find . -type f \( -name "*.tar.gz" -o -name "*.zip" -o -name "*.deb" -o -name "*.rpm" -o -name "*.apk" \) -print0 | while IFS= read -r -d '' file; do
            filename=$(basename "$file")
            echo "Signing $filename with Cosign..."

            # Keyless signing with GitHub OIDC
            cosign sign-blob "$file" \
              --yes \
              --oidc-issuer https://token.actions.githubusercontent.com \
              "${COSIGN_KEY_ARGS:-}" \
              --bundle "${file}.cosign.bundle" \
              --output-certificate "${file}.cosign.cert" \
              --output-signature "${file}.cosign.sig"

            echo "Created Cosign bundle for $filename"
          done
          cd ..

      - name: Generate GitHub Attestations
        uses: actions/attest-build-provenance@v1.5.0
        with:
          subject-path: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip
            artifacts/**/*.deb
            artifacts/**/*.rpm

      - name: Generate and sign checksums
        run: |
          cd artifacts
          # Find all release files and generate checksums
          find . -type f \( -name "*.tar.gz" -o -name "*.zip" -o -name "*.deb" -o -name "*.rpm" -o -name "*.apk" \) -print0 | while IFS= read -r -d '' file; do
            sha256sum "$file" | sed 's|^\./||'
          done >> ../checksums.txt
          cd ..

          # Create formatted checksum file
          {
            echo "# SHA256 Checksums for Rusty Commit ${{ needs.create-release.outputs.version }}"
            echo "# Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
          } > SHA256SUMS.txt
          if [ -f checksums.txt ]; then
            sort checksums.txt >> SHA256SUMS.txt
          fi

          # Sign checksum file with GPG if configured
          if [ "$GPG_CONFIGURED" = "true" ]; then
            gpg --batch --yes --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
                --pinentry-mode loopback \
                --armor --detach-sign \
                --output SHA256SUMS.txt.asc \
                SHA256SUMS.txt
            echo "Checksum file signed with GPG"
          else
            echo "GPG not configured, skipping checksum GPG signature"
          fi

          # Also sign checksums with Cosign
          echo "Signing checksums with Cosign..."
          cosign sign-blob SHA256SUMS.txt \
            --yes \
            --oidc-issuer https://token.actions.githubusercontent.com \
            "${COSIGN_KEY_ARGS:-}" \
            --bundle SHA256SUMS.txt.cosign.bundle \
            --output-certificate SHA256SUMS.txt.cosign.cert \
            --output-signature SHA256SUMS.txt.cosign.sig

      - name: Sign install script
        run: |
          # Copy install script to release artifacts
          cp install.sh install.sh.release

          # Sign install script with GPG if configured
          if [ "$GPG_CONFIGURED" = "true" ]; then
            gpg --batch --yes --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
                --pinentry-mode loopback \
                --armor --detach-sign \
                --output install.sh.asc \
                install.sh.release
            echo "Install script signed with GPG"
          else
            echo "GPG not configured, skipping install script GPG signature"
          fi

          # Sign install script with Cosign
          echo "Signing install script with Cosign..."
          cosign sign-blob install.sh.release \
            --yes \
            --oidc-issuer https://token.actions.githubusercontent.com \
            "${COSIGN_KEY_ARGS:-}" \
            --bundle install.sh.cosign.bundle \
            --output-certificate install.sh.cosign.cert \
            --output-signature install.sh.cosign.sig

      - name: Create detached signatures for binaries
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          if [ "$GPG_CONFIGURED" = "true" ]; then
            cd artifacts
            # Sign each tar.gz and zip file with detached signature
            find . -type f \( -name "*.tar.gz" -o -name "*.zip" \) -print0 | while IFS= read -r -d '' file; do
              echo "Signing $file with GPG..."
              gpg --batch --yes --passphrase "$GPG_PASSPHRASE" \
                  --pinentry-mode loopback \
                  --armor --detach-sign \
                  --output "${file}.asc" \
                  "$file"
            done
            cd ..
          else
            echo "GPG not configured, skipping binary GPG signatures"
          fi

      - name: Upload checksums
        uses: softprops/action-gh-release@v2
        with:
          files: ./SHA256SUMS.txt
          tag_name: ${{ github.ref }}

      - name: Upload signed checksums
        if: env.GPG_CONFIGURED == 'true'
        uses: softprops/action-gh-release@v2
        with:
          files: ./SHA256SUMS.txt.asc
          tag_name: ${{ github.ref }}

      - name: Upload install script and signatures
        run: |
          # Upload install script
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Content-Type: application/x-sh" \
            --data-binary "@install.sh.release" \
            "${{ needs.create-release.outputs.upload_url }}?name=install.sh&label=install.sh"

          # Upload install script signatures
          for file in install.sh.asc install.sh.cosign.*; do
            if [ -f "$file" ]; then
              echo "Uploading install script signature: $file"
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Content-Type: application/octet-stream" \
                --data-binary "@$file" \
                "${{ needs.create-release.outputs.upload_url }}?name=$file&label=$file"
            fi
          done

      - name: Upload binary signatures
        run: |
          cd artifacts
          # Upload all .asc signature files
          find . -name "*.asc" -print0 | while IFS= read -r -d '' sig; do
            filename=$(basename "$sig")
            echo "Uploading GPG signature: $filename"
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$sig" \
              "${{ needs.create-release.outputs.upload_url }}?name=$filename&label=${filename}"
          done

      - name: Upload Cosign signatures and bundles
        run: |
          cd artifacts
          # Upload Cosign signature files (.sig, .cert, .bundle) for all packages
          find . \( -name "*.cosign.sig" -o -name "*.cosign.cert" -o -name "*.cosign.bundle" \) -print0 | while IFS= read -r -d '' sig; do
            filename=$(basename "$sig")
            echo "Uploading Cosign artifact: $filename"
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$sig" \
              "${{ needs.create-release.outputs.upload_url }}?name=$filename&label=${filename}"
          done

          # Upload main checksum Cosign files
          cd ..
          for file in SHA256SUMS.txt.cosign.*; do
            if [ -f "$file" ]; then
              echo "Uploading: $file"
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Content-Type: application/octet-stream" \
                --data-binary "@$file" \
                "${{ needs.create-release.outputs.upload_url }}?name=$file&label=$file"
            fi
          done
