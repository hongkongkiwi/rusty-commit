name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version
        id: get_version
        run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ steps.get_version.outputs.version }}
          draft: false
          prerelease: false
          body: |
            # Rusty Commit ${{ steps.get_version.outputs.version }}

            ðŸš€ **Blazing-fast commit messages powered by AI and written in Rust** ðŸ¦€

            ## What's New
            - 16+ AI providers supported (Anthropic, OpenAI, OpenRouter, Groq, DeepSeek, and more)
            - Interactive authentication with beautiful provider selection
            - Secure credential storage with system keychain integration
            - Full OpenCommit compatibility with enhanced Rust performance

            ## Installation

            ### macOS / Linux
            ```bash
            # Download and extract (replace URL with your platform)
            curl -L https://github.com/${{ github.repository }}/releases/download/${{ steps.get_version.outputs.version }}/rustycommit-<platform>.tar.gz | tar xz

            # Move to PATH
            sudo mv rco /usr/local/bin/
            ```

            ### Windows
            Download the Windows zip file and add `rco.exe` to your PATH.

            ### Using Cargo
            ```bash
            cargo install rusty-commit
            # With secure storage
            cargo install rusty-commit --features secure-storage
            ```

  build-release:
    name: Build Release (${{ matrix.target }})
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          # Linux builds
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            archive-name: rustycommit-linux-x86_64.tar.gz
            use-cross: false

          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            archive-name: rustycommit-linux-x86_64-musl.tar.gz
            use-cross: true

          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            archive-name: rustycommit-linux-aarch64.tar.gz
            use-cross: true

          - os: ubuntu-latest
            target: riscv64gc-unknown-linux-gnu
            archive-name: rustycommit-linux-riscv64.tar.gz
            use-cross: true

          - os: ubuntu-latest
            target: armv7-unknown-linux-gnueabihf
            archive-name: rustycommit-linux-armv7.tar.gz
            use-cross: true

          # macOS builds
          - os: macos-latest
            target: x86_64-apple-darwin
            archive-name: rustycommit-macos-x86_64.tar.gz
            use-cross: false

          - os: macos-latest
            target: aarch64-apple-darwin
            archive-name: rustycommit-macos-aarch64.tar.gz
            use-cross: false

          # Windows builds
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            archive-name: rustycommit-windows-x86_64.zip
            use-cross: false

          - os: windows-latest
            target: i686-pc-windows-msvc
            archive-name: rustycommit-windows-i686.zip
            use-cross: false
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross
        if: matrix.use-cross
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Build with cross
        if: matrix.use-cross
        run: cross build --release --target ${{ matrix.target }}

      - name: Build with cargo
        if: ${{ !matrix.use-cross }}
        run: cargo build --release --target ${{ matrix.target }}

      - name: Create archive (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          mkdir -p archive
          cp target/${{ matrix.target }}/release/rco archive/ 2>/dev/null || true
          cd archive
          tar czf ../${{ matrix.archive-name }} .

      - name: Create archive (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path archive
          Copy-Item "target\${{ matrix.target }}\release\rco.exe" -Destination "archive\"
          Compress-Archive -Path "archive\*" -DestinationPath "${{ matrix.archive-name }}"

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./${{ matrix.archive-name }}
          asset_name: ${{ matrix.archive-name }}
          asset_content_type: application/octet-stream

  # Crate publishing is now handled by publish.yml which triggers on release published event
  # OS package creation is handled by package-release.yml which also triggers on release published event

  # Sign and finalize release artifacts
  sign-and-finalize:
    name: Sign Release Artifacts
    needs: [create-release, build-release]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write  # Required for Sigstore keyless signing
      attestations: write  # Required for GitHub attestations
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v3
        with:
          path: artifacts

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.2.2'

      - name: Setup GPG
        if: env.GPG_PRIVATE_KEY != ''
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          # Import GPG key
          echo "$GPG_PRIVATE_KEY" | base64 -d | gpg --batch --import
          
          # Configure GPG
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          echo "use-agent" >> ~/.gnupg/gpg.conf
          gpg-connect-agent reloadagent /bye
          
          # Test signing
          echo "test" | gpg --batch --yes --passphrase "$GPG_PASSPHRASE" \
              --pinentry-mode loopback --armor --detach-sign > /dev/null
          
          echo "GPG signing configured successfully"

      - name: Sign binaries with Cosign (Sigstore)
        run: |
          cd artifacts
          # Sign each binary/archive with Cosign keyless signing
          find . -type f \( -name "*.tar.gz" -o -name "*.zip" \) | while read file; do
            filename=$(basename "$file")
            echo "Signing $filename with Cosign..."
            
            # Keyless signing with GitHub OIDC
            cosign sign-blob "$file" \
              --yes \
              --oidc-issuer https://token.actions.githubusercontent.com \
              --bundle "${file}.cosign.bundle" \
              --output-certificate "${file}.cosign.cert" \
              --output-signature "${file}.cosign.sig"
            
            echo "Created Cosign bundle for $filename"
          done
          cd ..

      - name: Generate GitHub Attestations
        uses: actions/attest-build-provenance@v1
        with:
          subject-path: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip
            artifacts/**/*.deb
            artifacts/**/*.rpm

      - name: Generate and sign checksums
        run: |
          cd artifacts
          # Find all release files and generate checksums
          find . -type f \( -name "*.tar.gz" -o -name "*.zip" -o -name "*.deb" -o -name "*.rpm" -o -name "*.apk" \) | while read file; do
            sha256sum "$file" | sed 's|^\./||' >> ../checksums.txt
          done
          cd ..
          
          # Create formatted checksum file
          echo "# SHA256 Checksums for Rusty Commit ${{ needs.create-release.outputs.version }}" > SHA256SUMS.txt
          echo "# Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> SHA256SUMS.txt
          echo "" >> SHA256SUMS.txt
          if [ -f checksums.txt ]; then
            sort checksums.txt >> SHA256SUMS.txt
          fi
          
          # Sign checksum file if GPG available
          if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            gpg --batch --yes --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
                --pinentry-mode loopback \
                --armor --detach-sign \
                --output SHA256SUMS.txt.asc \
                SHA256SUMS.txt
            echo "Checksum file signed with GPG"
          fi
          
          # Also sign checksums with Cosign
          echo "Signing checksums with Cosign..."
          cosign sign-blob SHA256SUMS.txt \
            --yes \
            --oidc-issuer https://token.actions.githubusercontent.com \
            --bundle SHA256SUMS.txt.cosign.bundle \
            --output-certificate SHA256SUMS.txt.cosign.cert \
            --output-signature SHA256SUMS.txt.cosign.sig

      - name: Create detached signatures for binaries
        if: env.GPG_PRIVATE_KEY != ''
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          cd artifacts
          # Sign each tar.gz and zip file with detached signature
          find . -type f \( -name "*.tar.gz" -o -name "*.zip" \) | while read file; do
            echo "Signing $file..."
            gpg --batch --yes --passphrase "$GPG_PASSPHRASE" \
                --pinentry-mode loopback \
                --armor --detach-sign \
                --output "${file}.asc" \
                "$file"
          done
          cd ..

      - name: Upload checksums
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./SHA256SUMS.txt
          asset_name: SHA256SUMS.txt
          asset_content_type: text/plain

      - name: Upload signed checksums
        if: env.GPG_PRIVATE_KEY != ''
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./SHA256SUMS.txt.asc
          asset_name: SHA256SUMS.txt.asc
          asset_content_type: text/plain

      - name: Upload binary signatures
        if: env.GPG_PRIVATE_KEY != ''
        run: |
          cd artifacts
          # Upload all .asc signature files
          find . -name "*.asc" | while read sig; do
            filename=$(basename "$sig")
            echo "Uploading GPG signature: $filename"
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$sig" \
              "${{ needs.create-release.outputs.upload_url }}?name=$filename&label=${filename}"
          done

      - name: Upload Cosign signatures and bundles
        run: |
          cd artifacts
          # Upload Cosign signature files (.sig, .cert, .bundle)
          find . \( -name "*.cosign.sig" -o -name "*.cosign.cert" -o -name "*.cosign.bundle" \) | while read sig; do
            filename=$(basename "$sig")
            echo "Uploading Cosign artifact: $filename"
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$sig" \
              "${{ needs.create-release.outputs.upload_url }}?name=$filename&label=${filename}"
          done
          
          # Upload main checksum Cosign files
          cd ..
          for file in SHA256SUMS.txt.cosign.*; do
            if [ -f "$file" ]; then
              echo "Uploading: $file"
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Content-Type: application/octet-stream" \
                --data-binary "@$file" \
                "${{ needs.create-release.outputs.upload_url }}?name=$file&label=$file"
            fi
          done
